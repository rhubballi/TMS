import PDFDocument from 'pdfkit';
import fs from 'fs';
import path from 'path';
import { ITrainingRecord } from '../models/TrainingRecord';
import { IUser } from '../models/User';
import { ITraining } from '../models/Training';
import { ITrainingMaster } from '../models/TrainingMaster';

// Ensure upload directory exists
const UPLOAD_DIR = path.join(__dirname, '../../uploads/certificates');
if (!fs.existsSync(UPLOAD_DIR)) {
    fs.mkdirSync(UPLOAD_DIR, { recursive: true });
}

export const generateCertificateId = (
    user: IUser | any,
    training: ITraining | any
): string => {
    // Format: [Code]-[Initials]-[Date]-[Random]
    // Example: PYL-001-JD-20231027-A1B2

    const code = training.code || 'TRN';

    const initials = user.name
        ? user.name.split(' ').map((n: string) => n[0]).join('').toUpperCase().substring(0, 3)
        : 'EMP';

    const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, ''); // YYYYMMDD

    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');

    return `${code}-${initials}-${dateStr}-${random}`;
};

export const generateCertificatePDF = async (
    record: ITrainingRecord | any,
    user: IUser | any,
    training: ITraining | any,
    master: ITrainingMaster | any
): Promise<string> => {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({
                layout: 'landscape',
                size: 'A4',
                margin: 50
            });

            const fileName = `CERT-${record._id}-${Date.now()}.pdf`;
            const filePath = path.join(UPLOAD_DIR, fileName);
            const writeStream = fs.createWriteStream(filePath);

            doc.pipe(writeStream);

            // --- Design ---

            // Border
            doc.rect(20, 20, doc.page.width - 40, doc.page.height - 40).stroke();
            doc.rect(40, 40, doc.page.width - 80, doc.page.height - 80).stroke();

            // Header
            doc.font('Helvetica-Bold').fontSize(30).text('CERTIFICATE OF COMPLETION', 0, 100, { align: 'center' });

            doc.moveDown();
            doc.font('Helvetica').fontSize(15).text('This is to certify that', { align: 'center' });

            doc.moveDown();
            doc.font('Helvetica-Bold').fontSize(25).text(user.name, { align: 'center' });

            doc.moveDown();
            doc.font('Helvetica').fontSize(15).text('Has successfully completed the training', { align: 'center' });

            doc.moveDown();
            doc.font('Helvetica-Bold').fontSize(20).text(training.title, { align: 'center' });

            if (master && master.training_code) {
                doc.fontSize(12).text(`Code: ${master.training_code} | Version: ${training.version || '1.0'}`, { align: 'center' });
            }

            doc.moveDown(2);

            // Details Table-ish
            const startY = doc.y;
            const leftX = 200;
            const rightX = 500;

            doc.font('Helvetica').fontSize(12);
            doc.text(`Completed On: ${new Date().toLocaleDateString()}`, leftX, startY);

            if (record.expiryDate) {
                doc.text(`Valid Until: ${new Date(record.expiryDate).toLocaleDateString()}`, rightX, startY);
            } else {
                doc.text(`Valid Until: N/A`, rightX, startY);
            }

            doc.moveDown(2);
            doc.font('Helvetica-Bold').fontSize(16);
            const resultLabel = record.resultGrade === 'EXCELLENT' ? 'EXCELLENT' : 'PASS';
            doc.text(`Result: ${resultLabel}`, 0, doc.y, { align: 'center' });

            doc.moveDown(4);

            // Footer / System ID
            doc.fontSize(10).text(`Certificate ID: ${record.certificateId}`, 50, doc.page.height - 80);
            doc.text(`Generated by TMS System`, 50, doc.page.height - 65);
            doc.text(`This is a system generated certificate and needs no signature.`, { align: 'center', width: doc.page.width, height: doc.page.height - 65 });

            doc.end();

            writeStream.on('finish', () => {
                // Return relative path for URL
                resolve(`/uploads/certificates/${fileName}`); // Adjust based on how you serve static files
            });

            writeStream.on('error', (err) => {
                reject(err);
            });

        } catch (err) {
            reject(err);
        }
    });
};
